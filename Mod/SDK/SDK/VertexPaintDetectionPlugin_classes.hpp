#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: VertexPaintDetectionPlugin

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "VertexPaintDetectionPlugin_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "DeveloperSettings_classes.hpp"
#include "PhysicsCore_structs.hpp"


namespace SDK
{

// Class VertexPaintDetectionPlugin.VertexPaintDetectionComponent
// 0x0408 (0x04A8 - 0x00A0)
class UVertexPaintDetectionComponent : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(struct FRVPDPTaskResults& TaskResultInfo, struct FRVPDPGetClosestVertexDataSettings& DetectedMeshWithSettings, struct FRVPDPClosestVertexDataResults& ClosestVertexInfo, struct FRVPDPEstimatedColorAtHitLocationInfo& EstimatedColorAtHitLocationInfo, struct FRVPDPAverageColorInAreaInfo& AvarageColorInAreaInfo, struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData)> GetClosestVertexDataDelegate;                      // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FRVPDPTaskResults& TaskResultInfo, struct FRVPDPGetColorsOnlySettings& GotAllVertexColorsWithSettings, struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData)> GetAllVertexColorsOnlyDelegate;                    // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FRVPDPTaskResults& TaskResultInfo, struct FRVPDPGetColorsWithinAreaSettings& GetColorsWithinAreaSettings, struct FRVPDPWithinAreaResults& WithinAreaResults, struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData)> GetColorsWithinAreaDelegate;                       // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FRVPDPTaskResults& TaskResultInfo, struct FRVPDPPaintTaskResultInfo& PaintTaskResultInfo, struct FRVPDPPaintAtLocationSettings& PaintedAtLocationWithSettings, struct FRVPDPClosestVertexDataResults& ClosestVertexInfoAfterApplyingColor, struct FRVPDPEstimatedColorAtHitLocationInfo& EstimatedColorAtHitLocationInfo, struct FRVPDPAverageColorInAreaInfo& AvarageColorInAreaInfo, struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData)> VertexColorsPaintedAtLocationDelegate;             // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FRVPDPTaskResults& TaskResultInfo, struct FRVPDPPaintTaskResultInfo& PaintTaskResultInfo, struct FRVPDPPaintWithinAreaSettings& PaintedWithinAreaWithSettings, struct FRVPDPWithinAreaResults& WithinAreaResults, struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData)> VertexColorsPaintedMeshWithinAreaDelegate;         // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FRVPDPTaskResults& TaskResultInfo, struct FRVPDPPaintTaskResultInfo& PaintTaskResultInfo, struct FRVPDPPaintOnEntireMeshSettings& EntireMeshPaintedWithSettings, struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData)> VertexColorsPaintedEntireMeshDelegate;             // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FRVPDPTaskResults& TaskResultInfo, struct FRVPDPPaintTaskResultInfo& PaintTaskResultInfo, struct FRVPDPPaintColorSnippetSettings& PaintColorSnippetWithSettings, struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData)> VertexColorsPaintColorSnippetDelegate;             // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FRVPDPTaskResults& TaskResultInfo, struct FRVPDPPaintTaskResultInfo& PaintTaskResultInfo, struct FRVPDPSetVertexColorsSettings& SetMeshComponentVertexColorWithSettings, struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData)> VertexColorsSetMeshColorsDelegate;                 // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FRVPDPTaskResults& TaskResultInfo, struct FRVPDPPaintTaskResultInfo& PaintTaskResultInfo, struct FRVPDPSetVertexColorsUsingSerializedStringSettings& SetMeshComponentVertexColorUsingSerializedStringWithSettings, struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData)> VertexColorsSetMeshColorsUsingSerializedStringDelegate; // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0x50];                                     // 0x0130(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UPrimitiveComponent*>       CurrentGetClosestVertexDataTasks;                  // 0x0180(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class UPrimitiveComponent*>       CurrentGetAllVertexColorsOnlyTasks;                // 0x01D0(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class UPrimitiveComponent*>       CurrentGetColorsWithinAreaTasks;                   // 0x0220(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class UPrimitiveComponent*>       CurrentPaintAtLocationTasks;                       // 0x0270(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class UPrimitiveComponent*>       CurrentPaintWithinAreaTasks;                       // 0x02C0(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class UPrimitiveComponent*>       CurrentPaintEntireMeshTasks;                       // 0x0310(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class UPrimitiveComponent*>       CurrentPaintColorSnippetTasks;                     // 0x0360(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class UPrimitiveComponent*>       CurrentSetMeshComponentVertexColorsTasks;          // 0x03B0(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class UPrimitiveComponent*>       CurrentSetMeshComponentVertexColorsUsingSerializedStringTasks; // 0x0400(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, class UVertexPaintColorSnippetDataAsset*> LoadedCompareColorSnippetDataAssets;               // 0x0450(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A0[0x8];                                      // 0x04A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TMap<int32, class UPrimitiveComponent*> GetCurrentGetAllVertexColorsOnlyTasks();
	TMap<int32, class UPrimitiveComponent*> GetCurrentGetClosestVertexDataTasks();
	TMap<int32, class UPrimitiveComponent*> GetCurrentGetColorsWithinAreaTasks();
	TMap<int32, class UPrimitiveComponent*> GetCurrentPaintAtLocationTasks();
	TMap<int32, class UPrimitiveComponent*> GetCurrentPaintColorSnippetTasks();
	TMap<int32, class UPrimitiveComponent*> GetCurrentPaintEntireMeshTasks();
	TMap<int32, class UPrimitiveComponent*> GetCurrentPaintWithinAreaTasks();
	TMap<int32, class UPrimitiveComponent*> GetCurrentSetMeshComponentVertexColorsTasks();
	TMap<int32, class UPrimitiveComponent*> GetCurrentSetMeshComponentVertexColorsUsingSerializedStringTasks();
	void GetCurrentTasksInitiatedByComponent(int32* TotalAmountOfTasks, int32* AmountOfGetClosestVertexDataTasks, int32* AmountOfGetAllVertexColorsOnlyTasks, int32* AmountOfGetColorsWithinAreaTasks, int32* AmountOfPaintAtLocationTasks, int32* AmountOfPaintWithinAreaTasks, int32* AmountOfPaintEntireMeshTasks, int32* AmountOfPaintColorSnippetTasks, int32* AmountOfSetMeshComponentVertexColorsTasks, int32* AmountOfSetMeshComponentVertexColorsUsingSerializedStringTasks);
	TArray<class UPrimitiveComponent*> GetCurrentTasksMeshComponents();
	int32 GetTotalTasksInitiatedByComponent();
	bool HasAnyTasksQueuedUp();
	void TaskRemovedByTaskQueue(const struct FRVPDPCalculateColorsInfo& CalculateColorsInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintDetectionComponent">();
	}
	static class UVertexPaintDetectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexPaintDetectionComponent>();
	}
};
static_assert(alignof(UVertexPaintDetectionComponent) == 0x000008, "Wrong alignment on UVertexPaintDetectionComponent");
static_assert(sizeof(UVertexPaintDetectionComponent) == 0x0004A8, "Wrong size on UVertexPaintDetectionComponent");
static_assert(offsetof(UVertexPaintDetectionComponent, GetClosestVertexDataDelegate) == 0x0000A0, "Member 'UVertexPaintDetectionComponent::GetClosestVertexDataDelegate' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, GetAllVertexColorsOnlyDelegate) == 0x0000B0, "Member 'UVertexPaintDetectionComponent::GetAllVertexColorsOnlyDelegate' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, GetColorsWithinAreaDelegate) == 0x0000C0, "Member 'UVertexPaintDetectionComponent::GetColorsWithinAreaDelegate' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, VertexColorsPaintedAtLocationDelegate) == 0x0000D0, "Member 'UVertexPaintDetectionComponent::VertexColorsPaintedAtLocationDelegate' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, VertexColorsPaintedMeshWithinAreaDelegate) == 0x0000E0, "Member 'UVertexPaintDetectionComponent::VertexColorsPaintedMeshWithinAreaDelegate' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, VertexColorsPaintedEntireMeshDelegate) == 0x0000F0, "Member 'UVertexPaintDetectionComponent::VertexColorsPaintedEntireMeshDelegate' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, VertexColorsPaintColorSnippetDelegate) == 0x000100, "Member 'UVertexPaintDetectionComponent::VertexColorsPaintColorSnippetDelegate' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, VertexColorsSetMeshColorsDelegate) == 0x000110, "Member 'UVertexPaintDetectionComponent::VertexColorsSetMeshColorsDelegate' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, VertexColorsSetMeshColorsUsingSerializedStringDelegate) == 0x000120, "Member 'UVertexPaintDetectionComponent::VertexColorsSetMeshColorsUsingSerializedStringDelegate' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, CurrentGetClosestVertexDataTasks) == 0x000180, "Member 'UVertexPaintDetectionComponent::CurrentGetClosestVertexDataTasks' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, CurrentGetAllVertexColorsOnlyTasks) == 0x0001D0, "Member 'UVertexPaintDetectionComponent::CurrentGetAllVertexColorsOnlyTasks' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, CurrentGetColorsWithinAreaTasks) == 0x000220, "Member 'UVertexPaintDetectionComponent::CurrentGetColorsWithinAreaTasks' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, CurrentPaintAtLocationTasks) == 0x000270, "Member 'UVertexPaintDetectionComponent::CurrentPaintAtLocationTasks' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, CurrentPaintWithinAreaTasks) == 0x0002C0, "Member 'UVertexPaintDetectionComponent::CurrentPaintWithinAreaTasks' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, CurrentPaintEntireMeshTasks) == 0x000310, "Member 'UVertexPaintDetectionComponent::CurrentPaintEntireMeshTasks' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, CurrentPaintColorSnippetTasks) == 0x000360, "Member 'UVertexPaintDetectionComponent::CurrentPaintColorSnippetTasks' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, CurrentSetMeshComponentVertexColorsTasks) == 0x0003B0, "Member 'UVertexPaintDetectionComponent::CurrentSetMeshComponentVertexColorsTasks' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, CurrentSetMeshComponentVertexColorsUsingSerializedStringTasks) == 0x000400, "Member 'UVertexPaintDetectionComponent::CurrentSetMeshComponentVertexColorsUsingSerializedStringTasks' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionComponent, LoadedCompareColorSnippetDataAssets) == 0x000450, "Member 'UVertexPaintDetectionComponent::LoadedCompareColorSnippetDataAssets' has a wrong offset!");

// Class VertexPaintDetectionPlugin.AutoAddColorComponent
// 0x0410 (0x08B8 - 0x04A8)
class UAutoAddColorComponent : public UVertexPaintDetectionComponent
{
public:
	uint8                                         Pad_4A8[0x8];                                      // 0x04A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FRVPDPStartNewRoundOfTasksInfo& StartedNewRoundOfTasksOnMeshes)> StartedNewRoundOfTasksDelegate;                    // 0x04B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UPrimitiveComponent* MeshComponent)> StartedAutoPaintingMeshDelegate;                   // 0x04C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              VerifiedAutoPaintingMeshesDelegate;                // 0x04D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         ConsiderMeshFullyPaintedIfOverOrEqual;             // 0x04E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ApplyOneFrameDelayBetweenTasksForInstigatingComponent; // 0x04E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E5[0x3];                                      // 0x04E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VerifyMeshComponentsInterval;                      // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyStartNewRoundOfTasksIfAllHasBeenFinished;      // 0x04EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4ED[0x3];                                      // 0x04ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumDurationOfRoundOfTasks;                     // 0x04F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAllowedToAutoPaintAtBeginPlay;                   // 0x04F4(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoPaintRootMeshAtBeginPlay;                      // 0x04F5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F6[0x2];                                      // 0x04F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRVPDPAutoAddColorSettings             AutoPaintRootMeshAtBeginPlay_DelaySettings;        // 0x04F8(0x0318)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          PrintDebugLogsToScreen;                            // 0x0810(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_811[0x3];                                      // 0x0811(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PrintDebugLogsToScreen_Duration;                   // 0x0814(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PrintDebugLogsToOutputLog;                         // 0x0818(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_819[0x7];                                      // 0x0819(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UPrimitiveComponent*, struct FRVPDPAutoAddColorSettings> AutoPaintingMeshes;                                // 0x0820(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_870[0x48];                                     // 0x0870(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AutoPaintDelayFinished(class UPrimitiveComponent* MeshComponent);
	void AutoPaintedActorDestroyed(class AActor* DestroyedActor);
	void PauseAllAutoPainting();
	void PauseAutoPaintingMesh(class UPrimitiveComponent* MeshComponent);
	void ResumeAllAutoPainting();
	void ResumeAutoPaintingMesh(class UPrimitiveComponent* MeshComponent);
	void SetIfAutoPaintedMeshShouldOnlyStartNewTaskIfChangeWasMade(class UPrimitiveComponent* MeshComponent, bool OnlyStartNewTaskIfChangeWasMade);
	void StartNewRoundOfTasks();
	void StopAllAutoPainting();
	void StopAutoPaintingMesh(class UPrimitiveComponent* MeshComponent);

	bool CanAutoPaintedMeshGetPaused(const class UPrimitiveComponent* MeshComponent) const;
	bool GetIfMeshShouldOnlyStartNewTaskIfChangeWasMade(const class UPrimitiveComponent* MeshComponent) const;
	bool GetIsAutoPainting() const;
	TMap<class UPrimitiveComponent*, struct FRVPDPAutoAddColorSettings> GetMeshesBeingAutoPainted() const;
	bool IsAutoPaintedMeshPaused(const class UPrimitiveComponent* MeshComponent) const;
	bool IsNewRoundOfTasksGoingToStartAfterDelay() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoAddColorComponent">();
	}
	static class UAutoAddColorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoAddColorComponent>();
	}
};
static_assert(alignof(UAutoAddColorComponent) == 0x000008, "Wrong alignment on UAutoAddColorComponent");
static_assert(sizeof(UAutoAddColorComponent) == 0x0008B8, "Wrong size on UAutoAddColorComponent");
static_assert(offsetof(UAutoAddColorComponent, StartedNewRoundOfTasksDelegate) == 0x0004B0, "Member 'UAutoAddColorComponent::StartedNewRoundOfTasksDelegate' has a wrong offset!");
static_assert(offsetof(UAutoAddColorComponent, StartedAutoPaintingMeshDelegate) == 0x0004C0, "Member 'UAutoAddColorComponent::StartedAutoPaintingMeshDelegate' has a wrong offset!");
static_assert(offsetof(UAutoAddColorComponent, VerifiedAutoPaintingMeshesDelegate) == 0x0004D0, "Member 'UAutoAddColorComponent::VerifiedAutoPaintingMeshesDelegate' has a wrong offset!");
static_assert(offsetof(UAutoAddColorComponent, ConsiderMeshFullyPaintedIfOverOrEqual) == 0x0004E0, "Member 'UAutoAddColorComponent::ConsiderMeshFullyPaintedIfOverOrEqual' has a wrong offset!");
static_assert(offsetof(UAutoAddColorComponent, ApplyOneFrameDelayBetweenTasksForInstigatingComponent) == 0x0004E4, "Member 'UAutoAddColorComponent::ApplyOneFrameDelayBetweenTasksForInstigatingComponent' has a wrong offset!");
static_assert(offsetof(UAutoAddColorComponent, VerifyMeshComponentsInterval) == 0x0004E8, "Member 'UAutoAddColorComponent::VerifyMeshComponentsInterval' has a wrong offset!");
static_assert(offsetof(UAutoAddColorComponent, OnlyStartNewRoundOfTasksIfAllHasBeenFinished) == 0x0004EC, "Member 'UAutoAddColorComponent::OnlyStartNewRoundOfTasksIfAllHasBeenFinished' has a wrong offset!");
static_assert(offsetof(UAutoAddColorComponent, MinimumDurationOfRoundOfTasks) == 0x0004F0, "Member 'UAutoAddColorComponent::MinimumDurationOfRoundOfTasks' has a wrong offset!");
static_assert(offsetof(UAutoAddColorComponent, IsAllowedToAutoPaintAtBeginPlay) == 0x0004F4, "Member 'UAutoAddColorComponent::IsAllowedToAutoPaintAtBeginPlay' has a wrong offset!");
static_assert(offsetof(UAutoAddColorComponent, AutoPaintRootMeshAtBeginPlay) == 0x0004F5, "Member 'UAutoAddColorComponent::AutoPaintRootMeshAtBeginPlay' has a wrong offset!");
static_assert(offsetof(UAutoAddColorComponent, AutoPaintRootMeshAtBeginPlay_DelaySettings) == 0x0004F8, "Member 'UAutoAddColorComponent::AutoPaintRootMeshAtBeginPlay_DelaySettings' has a wrong offset!");
static_assert(offsetof(UAutoAddColorComponent, PrintDebugLogsToScreen) == 0x000810, "Member 'UAutoAddColorComponent::PrintDebugLogsToScreen' has a wrong offset!");
static_assert(offsetof(UAutoAddColorComponent, PrintDebugLogsToScreen_Duration) == 0x000814, "Member 'UAutoAddColorComponent::PrintDebugLogsToScreen_Duration' has a wrong offset!");
static_assert(offsetof(UAutoAddColorComponent, PrintDebugLogsToOutputLog) == 0x000818, "Member 'UAutoAddColorComponent::PrintDebugLogsToOutputLog' has a wrong offset!");
static_assert(offsetof(UAutoAddColorComponent, AutoPaintingMeshes) == 0x000820, "Member 'UAutoAddColorComponent::AutoPaintingMeshes' has a wrong offset!");

// Class VertexPaintDetectionPlugin.AutoAddColorEntireMeshComponent
// 0x04F8 (0x0DB0 - 0x08B8)
class UAutoAddColorEntireMeshComponent final : public UAutoAddColorComponent
{
public:
	struct FRVPDPPaintOnEntireMeshSettings        AutoPaintRootMeshAtBeginPlay_PaintEntireMeshSettings; // 0x08B8(0x0458)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class UPrimitiveComponent*, struct FRVPDPPaintOnEntireMeshSettings> AutoPaintingEntireMeshesWithSettings;              // 0x0D10(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class UPrimitiveComponent*, struct FRVPDPAdditionalDataToPassThroughInfo> AutoPaintingEntireMeshesAdditionalDataSettings;    // 0x0D60(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	bool AddAutoPaintEntireMesh(class UPrimitiveComponent* MeshComponent, const struct FRVPDPPaintOnEntireMeshSettings& PaintEntireMeshSettings, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData, const struct FRVPDPAutoAddColorSettings& AutoAddColorSettings, bool ResumeIfPaused);
	TMap<class UPrimitiveComponent*, struct FRVPDPAdditionalDataToPassThroughInfo> GetAutoPaintingEntireMeshesAdditionalDataSettings();
	TMap<class UPrimitiveComponent*, struct FRVPDPPaintOnEntireMeshSettings> GetAutoPaintingEntireMeshesPaintSettings();
	void UpdateAutoPaintedEntireMesh(class UPrimitiveComponent* MeshComponent, const struct FRVPDPPaintOnEntireMeshSettings& PaintEntireMeshSettings, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData, const struct FRVPDPAutoAddColorSettings& AutoAddColorSettings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoAddColorEntireMeshComponent">();
	}
	static class UAutoAddColorEntireMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoAddColorEntireMeshComponent>();
	}
};
static_assert(alignof(UAutoAddColorEntireMeshComponent) == 0x000008, "Wrong alignment on UAutoAddColorEntireMeshComponent");
static_assert(sizeof(UAutoAddColorEntireMeshComponent) == 0x000DB0, "Wrong size on UAutoAddColorEntireMeshComponent");
static_assert(offsetof(UAutoAddColorEntireMeshComponent, AutoPaintRootMeshAtBeginPlay_PaintEntireMeshSettings) == 0x0008B8, "Member 'UAutoAddColorEntireMeshComponent::AutoPaintRootMeshAtBeginPlay_PaintEntireMeshSettings' has a wrong offset!");
static_assert(offsetof(UAutoAddColorEntireMeshComponent, AutoPaintingEntireMeshesWithSettings) == 0x000D10, "Member 'UAutoAddColorEntireMeshComponent::AutoPaintingEntireMeshesWithSettings' has a wrong offset!");
static_assert(offsetof(UAutoAddColorEntireMeshComponent, AutoPaintingEntireMeshesAdditionalDataSettings) == 0x000D60, "Member 'UAutoAddColorEntireMeshComponent::AutoPaintingEntireMeshesAdditionalDataSettings' has a wrong offset!");

// Class VertexPaintDetectionPlugin.AutoAddColorPaintAtLocComponent
// 0x00A0 (0x0958 - 0x08B8)
class UAutoAddColorPaintAtLocComponent final : public UAutoAddColorComponent
{
public:
	TMap<class UPrimitiveComponent*, struct FRVPDPPaintAtLocationSettings> AutoPaintingAtLocationWithSettings;                // 0x08B8(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class UPrimitiveComponent*, struct FRVPDPAdditionalDataToPassThroughInfo> AutoPaintingAtLocationAdditionalDataSettings;      // 0x0908(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	bool AddAutoPaintAtLocation(class UPrimitiveComponent* MeshComponent, const struct FRVPDPPaintAtLocationSettings& PaintAtLocationSettings, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData, const struct FRVPDPAutoAddColorSettings& AutoAddColorSettings, bool ResumeIfPaused);
	TMap<class UPrimitiveComponent*, struct FRVPDPAdditionalDataToPassThroughInfo> GetAutoPaintingAtLocationAdditionalDataSettings();
	TMap<class UPrimitiveComponent*, struct FRVPDPPaintAtLocationSettings> GetAutoPaintingAtLocationPaintSettings();
	void UpdateAutoPaintedAtLocation(class UPrimitiveComponent* MeshComponent, const struct FRVPDPPaintAtLocationSettings& PaintAtLocationSettings, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData, const struct FRVPDPAutoAddColorSettings& AutoAddColorSettings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoAddColorPaintAtLocComponent">();
	}
	static class UAutoAddColorPaintAtLocComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoAddColorPaintAtLocComponent>();
	}
};
static_assert(alignof(UAutoAddColorPaintAtLocComponent) == 0x000008, "Wrong alignment on UAutoAddColorPaintAtLocComponent");
static_assert(sizeof(UAutoAddColorPaintAtLocComponent) == 0x000958, "Wrong size on UAutoAddColorPaintAtLocComponent");
static_assert(offsetof(UAutoAddColorPaintAtLocComponent, AutoPaintingAtLocationWithSettings) == 0x0008B8, "Member 'UAutoAddColorPaintAtLocComponent::AutoPaintingAtLocationWithSettings' has a wrong offset!");
static_assert(offsetof(UAutoAddColorPaintAtLocComponent, AutoPaintingAtLocationAdditionalDataSettings) == 0x000908, "Member 'UAutoAddColorPaintAtLocComponent::AutoPaintingAtLocationAdditionalDataSettings' has a wrong offset!");

// Class VertexPaintDetectionPlugin.AutoAddColorWithinAreaComponent
// 0x0100 (0x09B8 - 0x08B8)
class UAutoAddColorWithinAreaComponent final : public UAutoAddColorComponent
{
public:
	int32                                         MaxAmountOfMeshesToCheckIfChangedPerFrame;         // 0x08B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyPaintOnMovingMeshZ;                            // 0x08BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyPaintOnMovingMeshXY;                           // 0x08BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyPaintOnRotatedMesh;                            // 0x08BE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnlyPaintOnReScaledMesh;                           // 0x08BF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class UPrimitiveComponent*, struct FRVPDPPaintWithinAreaSettings> AutoPaintingWithinAreaWithSettings;                // 0x08C0(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class UPrimitiveComponent*, struct FRVPDPAdditionalDataToPassThroughInfo> AutoPaintingWithinAreaAdditionalDataSettings;      // 0x0910(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class UPrimitiveComponent*, struct FTransform> MeshComponentsToCheckIfMoved;                      // 0x0960(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_9B0[0x8];                                      // 0x09B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddAutoPaintWithinArea(class UPrimitiveComponent* MeshComponent, const struct FRVPDPPaintWithinAreaSettings& PaintWithinAreaSettings, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData, const struct FRVPDPAutoAddColorSettings& AutoAddColorSettings, bool ResumeIfPaused);
	TMap<class UPrimitiveComponent*, struct FRVPDPAdditionalDataToPassThroughInfo> GetAutoPaintingWithinAreaAdditionalDataSettings();
	TMap<class UPrimitiveComponent*, struct FRVPDPPaintWithinAreaSettings> GetAutoPaintingWithinAreaPaintSettings();
	void UpdateAutoPaintedWithinArea(class UPrimitiveComponent* MeshComponent, const struct FRVPDPPaintWithinAreaSettings& PaintWithinAreaSettings, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData, const struct FRVPDPAutoAddColorSettings& AutoAddColorSettings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoAddColorWithinAreaComponent">();
	}
	static class UAutoAddColorWithinAreaComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoAddColorWithinAreaComponent>();
	}
};
static_assert(alignof(UAutoAddColorWithinAreaComponent) == 0x000008, "Wrong alignment on UAutoAddColorWithinAreaComponent");
static_assert(sizeof(UAutoAddColorWithinAreaComponent) == 0x0009B8, "Wrong size on UAutoAddColorWithinAreaComponent");
static_assert(offsetof(UAutoAddColorWithinAreaComponent, MaxAmountOfMeshesToCheckIfChangedPerFrame) == 0x0008B8, "Member 'UAutoAddColorWithinAreaComponent::MaxAmountOfMeshesToCheckIfChangedPerFrame' has a wrong offset!");
static_assert(offsetof(UAutoAddColorWithinAreaComponent, OnlyPaintOnMovingMeshZ) == 0x0008BC, "Member 'UAutoAddColorWithinAreaComponent::OnlyPaintOnMovingMeshZ' has a wrong offset!");
static_assert(offsetof(UAutoAddColorWithinAreaComponent, OnlyPaintOnMovingMeshXY) == 0x0008BD, "Member 'UAutoAddColorWithinAreaComponent::OnlyPaintOnMovingMeshXY' has a wrong offset!");
static_assert(offsetof(UAutoAddColorWithinAreaComponent, OnlyPaintOnRotatedMesh) == 0x0008BE, "Member 'UAutoAddColorWithinAreaComponent::OnlyPaintOnRotatedMesh' has a wrong offset!");
static_assert(offsetof(UAutoAddColorWithinAreaComponent, OnlyPaintOnReScaledMesh) == 0x0008BF, "Member 'UAutoAddColorWithinAreaComponent::OnlyPaintOnReScaledMesh' has a wrong offset!");
static_assert(offsetof(UAutoAddColorWithinAreaComponent, AutoPaintingWithinAreaWithSettings) == 0x0008C0, "Member 'UAutoAddColorWithinAreaComponent::AutoPaintingWithinAreaWithSettings' has a wrong offset!");
static_assert(offsetof(UAutoAddColorWithinAreaComponent, AutoPaintingWithinAreaAdditionalDataSettings) == 0x000910, "Member 'UAutoAddColorWithinAreaComponent::AutoPaintingWithinAreaAdditionalDataSettings' has a wrong offset!");
static_assert(offsetof(UAutoAddColorWithinAreaComponent, MeshComponentsToCheckIfMoved) == 0x000960, "Member 'UAutoAddColorWithinAreaComponent::MeshComponentsToCheckIfMoved' has a wrong offset!");

// Class VertexPaintDetectionPlugin.VertexPaintClothOverlapComponent
// 0x0190 (0x03C0 - 0x0230)
class UVertexPaintClothOverlapComponent final : public USceneComponent
{
public:
	bool                                          ClothOverlapTracingEnabled;                        // 0x0230(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231[0x3];                                      // 0x0231(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClothVertexTraceRadius;                            // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClothVertexTraceInterval;                          // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x4];                                      // 0x023C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      ClothObjectsToSphereTrace;                         // 0x0240(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          DebugClothSphereTraces;                            // 0x0250(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x3];                                      // 0x0251(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugClothSphereTracesDuration;                    // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 AttachedSkeletalMeshComponent;                     // 0x0258(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UClothingAssetBase*>             AttachedSkeletalMeshComponentClothingAssets;       // 0x0260(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class UPrimitiveComponent*, int32>       ClothOverlappingComponentAndItemsCache;            // 0x0270(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class UClothingAssetBase*, struct FTransform> ClothBoneTransformsInComponentSpace;               // 0x02C0(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class UClothingAssetBase*, struct FQuat> ClothBoneQuaternionsInComponentSpace;              // 0x0310(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class UPrimitiveComponent*, int32>       CurrentTraceOverlappingComponentAndItemsCache;     // 0x0360(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B0[0x10];                                     // 0x03B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<EObjectTypeQuery> GetClothObjectsToSphereTrace();
	void OnRep_ClothOverlapTracingEnabled();
	void SetClothObjectsTypesToSphereTrace(const TArray<EObjectTypeQuery>& ClothObjectTypes);
	void SetClothOverlapTracingEnabled(bool EnableClothTracing);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintClothOverlapComponent">();
	}
	static class UVertexPaintClothOverlapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexPaintClothOverlapComponent>();
	}
};
static_assert(alignof(UVertexPaintClothOverlapComponent) == 0x000010, "Wrong alignment on UVertexPaintClothOverlapComponent");
static_assert(sizeof(UVertexPaintClothOverlapComponent) == 0x0003C0, "Wrong size on UVertexPaintClothOverlapComponent");
static_assert(offsetof(UVertexPaintClothOverlapComponent, ClothOverlapTracingEnabled) == 0x000230, "Member 'UVertexPaintClothOverlapComponent::ClothOverlapTracingEnabled' has a wrong offset!");
static_assert(offsetof(UVertexPaintClothOverlapComponent, ClothVertexTraceRadius) == 0x000234, "Member 'UVertexPaintClothOverlapComponent::ClothVertexTraceRadius' has a wrong offset!");
static_assert(offsetof(UVertexPaintClothOverlapComponent, ClothVertexTraceInterval) == 0x000238, "Member 'UVertexPaintClothOverlapComponent::ClothVertexTraceInterval' has a wrong offset!");
static_assert(offsetof(UVertexPaintClothOverlapComponent, ClothObjectsToSphereTrace) == 0x000240, "Member 'UVertexPaintClothOverlapComponent::ClothObjectsToSphereTrace' has a wrong offset!");
static_assert(offsetof(UVertexPaintClothOverlapComponent, DebugClothSphereTraces) == 0x000250, "Member 'UVertexPaintClothOverlapComponent::DebugClothSphereTraces' has a wrong offset!");
static_assert(offsetof(UVertexPaintClothOverlapComponent, DebugClothSphereTracesDuration) == 0x000254, "Member 'UVertexPaintClothOverlapComponent::DebugClothSphereTracesDuration' has a wrong offset!");
static_assert(offsetof(UVertexPaintClothOverlapComponent, AttachedSkeletalMeshComponent) == 0x000258, "Member 'UVertexPaintClothOverlapComponent::AttachedSkeletalMeshComponent' has a wrong offset!");
static_assert(offsetof(UVertexPaintClothOverlapComponent, AttachedSkeletalMeshComponentClothingAssets) == 0x000260, "Member 'UVertexPaintClothOverlapComponent::AttachedSkeletalMeshComponentClothingAssets' has a wrong offset!");
static_assert(offsetof(UVertexPaintClothOverlapComponent, ClothOverlappingComponentAndItemsCache) == 0x000270, "Member 'UVertexPaintClothOverlapComponent::ClothOverlappingComponentAndItemsCache' has a wrong offset!");
static_assert(offsetof(UVertexPaintClothOverlapComponent, ClothBoneTransformsInComponentSpace) == 0x0002C0, "Member 'UVertexPaintClothOverlapComponent::ClothBoneTransformsInComponentSpace' has a wrong offset!");
static_assert(offsetof(UVertexPaintClothOverlapComponent, ClothBoneQuaternionsInComponentSpace) == 0x000310, "Member 'UVertexPaintClothOverlapComponent::ClothBoneQuaternionsInComponentSpace' has a wrong offset!");
static_assert(offsetof(UVertexPaintClothOverlapComponent, CurrentTraceOverlappingComponentAndItemsCache) == 0x000360, "Member 'UVertexPaintClothOverlapComponent::CurrentTraceOverlappingComponentAndItemsCache' has a wrong offset!");

// Class VertexPaintDetectionPlugin.VertexPaintColorSnippetDataAsset
// 0x0050 (0x0080 - 0x0030)
class UVertexPaintColorSnippetDataAsset final : public UDataAsset
{
public:
	TMap<class FString, struct FRVPDPColorSnippetDataInfo> SnippetColorData;                                  // 0x0030(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintColorSnippetDataAsset">();
	}
	static class UVertexPaintColorSnippetDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexPaintColorSnippetDataAsset>();
	}
};
static_assert(alignof(UVertexPaintColorSnippetDataAsset) == 0x000008, "Wrong alignment on UVertexPaintColorSnippetDataAsset");
static_assert(sizeof(UVertexPaintColorSnippetDataAsset) == 0x000080, "Wrong size on UVertexPaintColorSnippetDataAsset");
static_assert(offsetof(UVertexPaintColorSnippetDataAsset, SnippetColorData) == 0x000030, "Member 'UVertexPaintColorSnippetDataAsset::SnippetColorData' has a wrong offset!");

// Class VertexPaintDetectionPlugin.VertexPaintColorSnippetRefs
// 0x0110 (0x0140 - 0x0030)
class UVertexPaintColorSnippetRefs final : public UDataAsset
{
public:
	TMap<TSoftObjectPtr<class UObject>, struct FRVPDPColorSnippetReferenceDataInfo> StaticMeshesColorSnippets;                         // 0x0030(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TMap<TSoftObjectPtr<class UObject>, struct FRVPDPColorSnippetReferenceDataInfo> SkeletalMeshesColorSnippets;                       // 0x0080(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	TMap<class FString, struct FRVPDPGroupColorSnippetInfo> GroupSnippetsAndAssociatedMeshes;                  // 0x00D0(0x0050)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  AllAvailableColorSnippets;                         // 0x0120(0x0020)(NativeAccessSpecifierPublic)

public:
	bool CheckAndGetTheComponentsThatMatchGroupChildSnippets(const class UObject* WorldContextObject, const class FString& GroupSnippetID, const TArray<class UPrimitiveComponent*>& MeshComponents, TMap<class FString, class UPrimitiveComponent*>* ChildSnippetsAndMatchingMeshes);
	bool ContainsColorSnippet(const class FString& SnippetID, bool OptionalHasToBeStoredInDataAsset, class UVertexPaintColorSnippetDataAsset* DataAsset);
	TMap<class FString, struct FRVPDPStoredColorSnippetInfo> GetAllColorSnippetsAndDataAssetForObject(const class UObject* Object);
	TMap<class FString, struct FRVPDPStoredColorSnippetInfo> GetAllColorSnippetsInSpecifiedDataAsset(const class UVertexPaintColorSnippetDataAsset* ColorSnippetDataAsset, bool IncludeChildGroupSnippets);
	TMap<class FString, struct FRVPDPGroupColorSnippetInfo> GetAllGroupSnippetsInSpecifiedDataAsset(const class UVertexPaintColorSnippetDataAsset* ColorSnippetDataAsset);
	TMap<class FString, struct FRVPDPStoredColorSnippetInfo> GetChildSnippetInfosAssociatedWithGroupSnippetID(const class UObject* WorldContextObject, const class FString& GroupSnippetID);
	TSoftObjectPtr<class UObject> GetObjectFromSnippetID(const class FString& SnippetID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintColorSnippetRefs">();
	}
	static class UVertexPaintColorSnippetRefs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexPaintColorSnippetRefs>();
	}
};
static_assert(alignof(UVertexPaintColorSnippetRefs) == 0x000008, "Wrong alignment on UVertexPaintColorSnippetRefs");
static_assert(sizeof(UVertexPaintColorSnippetRefs) == 0x000140, "Wrong size on UVertexPaintColorSnippetRefs");
static_assert(offsetof(UVertexPaintColorSnippetRefs, StaticMeshesColorSnippets) == 0x000030, "Member 'UVertexPaintColorSnippetRefs::StaticMeshesColorSnippets' has a wrong offset!");
static_assert(offsetof(UVertexPaintColorSnippetRefs, SkeletalMeshesColorSnippets) == 0x000080, "Member 'UVertexPaintColorSnippetRefs::SkeletalMeshesColorSnippets' has a wrong offset!");
static_assert(offsetof(UVertexPaintColorSnippetRefs, GroupSnippetsAndAssociatedMeshes) == 0x0000D0, "Member 'UVertexPaintColorSnippetRefs::GroupSnippetsAndAssociatedMeshes' has a wrong offset!");
static_assert(offsetof(UVertexPaintColorSnippetRefs, AllAvailableColorSnippets) == 0x000120, "Member 'UVertexPaintColorSnippetRefs::AllAvailableColorSnippets' has a wrong offset!");

// Class VertexPaintDetectionPlugin.VertexPaintDetectionGISubSystem
// 0x01A0 (0x01D0 - 0x0030)
class UVertexPaintDetectionGISubSystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(struct FRVPDPTaskResults& TaskResultInfo, struct FRVPDPPaintTaskResultInfo& PaintTaskResultInfo, struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData)> VertexPaintTaskFinished;                           // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(struct FRVPDPTaskResults& TaskResultInfo, struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData)> VertexDetectTaskFinished;                          // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UVertexPaintDetectionTaskQueue*         TaskQueue;                                         // 0x0058(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class UPrimitiveComponent*, struct FRVPDPCallbackFromSpecifiedMeshComponentsInfo> PaintTaskCallbacksFromSpecificMeshComponents;      // 0x0060(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class UPrimitiveComponent*, struct FRVPDPCallbackFromSpecifiedMeshComponentsInfo> DetectTaskCallbacksFromSpecificMeshComponents;     // 0x00B0(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EPhysicalSurface, class UPhysicalMaterial*> PhysicalMaterialAssets;                            // 0x0110(0x0050)(NativeAccessSpecifierPrivate)
	class UVertexPaintColorSnippetRefs*           ColorSnippetReferenceDataAsset;                    // 0x0160(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVertexPaintOptimizationDataAsset*      OptimizationDataAsset;                             // 0x0168(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVertexPaintMaterialDataAsset*          MaterialDataAsset;                                 // 0x0170(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x58];                                     // 0x0178(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RegisteredDetectTaskCallbackOwnerDestroyed(class AActor* DestroyedActor);
	void RegisteredPaintTaskCallbackOwnerDestroyed(class AActor* DestroyedActor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintDetectionGISubSystem">();
	}
	static class UVertexPaintDetectionGISubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexPaintDetectionGISubSystem>();
	}
};
static_assert(alignof(UVertexPaintDetectionGISubSystem) == 0x000008, "Wrong alignment on UVertexPaintDetectionGISubSystem");
static_assert(sizeof(UVertexPaintDetectionGISubSystem) == 0x0001D0, "Wrong size on UVertexPaintDetectionGISubSystem");
static_assert(offsetof(UVertexPaintDetectionGISubSystem, VertexPaintTaskFinished) == 0x000038, "Member 'UVertexPaintDetectionGISubSystem::VertexPaintTaskFinished' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionGISubSystem, VertexDetectTaskFinished) == 0x000048, "Member 'UVertexPaintDetectionGISubSystem::VertexDetectTaskFinished' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionGISubSystem, TaskQueue) == 0x000058, "Member 'UVertexPaintDetectionGISubSystem::TaskQueue' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionGISubSystem, PaintTaskCallbacksFromSpecificMeshComponents) == 0x000060, "Member 'UVertexPaintDetectionGISubSystem::PaintTaskCallbacksFromSpecificMeshComponents' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionGISubSystem, DetectTaskCallbacksFromSpecificMeshComponents) == 0x0000B0, "Member 'UVertexPaintDetectionGISubSystem::DetectTaskCallbacksFromSpecificMeshComponents' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionGISubSystem, PhysicalMaterialAssets) == 0x000110, "Member 'UVertexPaintDetectionGISubSystem::PhysicalMaterialAssets' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionGISubSystem, ColorSnippetReferenceDataAsset) == 0x000160, "Member 'UVertexPaintDetectionGISubSystem::ColorSnippetReferenceDataAsset' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionGISubSystem, OptimizationDataAsset) == 0x000168, "Member 'UVertexPaintDetectionGISubSystem::OptimizationDataAsset' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionGISubSystem, MaterialDataAsset) == 0x000170, "Member 'UVertexPaintDetectionGISubSystem::MaterialDataAsset' has a wrong offset!");

// Class VertexPaintDetectionPlugin.VertexPaintDetectionInterface
// 0x0000 (0x0028 - 0x0028)
class IVertexPaintDetectionInterface final : public IInterface
{
public:
	void ClothBeginOverlappingMesh(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 Item);
	void ClothEndOverlappingMesh(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 Item);
	void ColorsAppliedOnActor(const struct FRVPDPTaskResults& TaskResultInfo, const struct FRVPDPPaintTaskResultInfo& PaintTaskResultInfo, const struct FRVPDPPaintTaskSettings& PaintedOnActorSettings, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData);
	void DetectTaskFinishedOnRegisteredMeshComponent(const struct FRVPDPTaskResults& TaskResultInfo, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData);
	void GetAllVertexColorsOnlyOnActor(const struct FRVPDPTaskResults& TaskResultInfo, const struct FRVPDPGetColorsOnlySettings& GotAllVertexColorsWithSettings, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData);
	void GetClosestVertexDataOnActor(const struct FRVPDPTaskResults& TaskResultInfo, const struct FRVPDPGetClosestVertexDataSettings& GetClosestVertexDataSettings, const struct FRVPDPClosestVertexDataResults& ClosestVertexColorResult, const struct FRVPDPEstimatedColorAtHitLocationInfo& EstimatedColorAtHitLocationResult, const struct FRVPDPAverageColorInAreaInfo& AverageColorInAreaInfo, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData);
	void GetColorsWithinArea(const struct FRVPDPTaskResults& TaskResultInfo, const struct FRVPDPGetColorsWithinAreaSettings& GetColorsWithinAreaSettings, const struct FRVPDPWithinAreaResults& WithinAreaResults, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData);
	TMap<class UClothingAssetBase*, struct FRVPDPVertexChannelsChaosClothPhysicsSettings> GetSkeletalMeshClothPhysicsSettings(class USkeletalMeshComponent* SkeletalMeshComponentTryingToGetClothSettingsFor);
	void OverrideVertexColorToApply(int32 OverrideID, class UVertexPaintDetectionComponent* AssociatedPaintComponent, class UPrimitiveComponent* MeshApplyingColorsTo, int32 CurrentLOD, int32 CurrentVertexIndex, class UMaterialInterface* MaterialVertexIsOn, bool IsVertexOnCloth, const class FName& BoneVertexIsOn, const struct FVector& VertexPositionInWorldSpace, const struct FVector& VertexNormal, const struct FColor& CurrentVertexColor, EPhysicalSurface CurrentVertexMostDominantPhysicsSurface, float CurrentVertexMostDominantPhysicsSurfaceValue, const struct FColor& UpdatedVertexColorToApply, bool WantsToApplyUpdatedVertexColor, bool* ApplyUpdatedOrOverridenVertexColors, bool* OverrideVertexColorsToApply, struct FColor* VertexColorsToOverrideWith);
	void PaintedOnActor_AtLocation(const struct FRVPDPTaskResults& TaskResultInfo, const struct FRVPDPPaintTaskResultInfo& PaintTaskResultInfo, const struct FRVPDPPaintAtLocationSettings& PaintedAtLocationSettings, const struct FRVPDPClosestVertexDataResults& ClosestVertexColorResult, const struct FRVPDPEstimatedColorAtHitLocationInfo& EstimatedColorAtHitLocationResult, const struct FRVPDPAverageColorInAreaInfo& AverageColorInAreaInfo, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData);
	void PaintedOnActor_EntireMesh(const struct FRVPDPTaskResults& TaskResultInfo, const struct FRVPDPPaintTaskResultInfo& PaintTaskResultInfo, const struct FRVPDPPaintOnEntireMeshSettings& PaintedEntireMeshSettings, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData);
	void PaintedOnActor_PaintColorSnippet(const struct FRVPDPTaskResults& TaskResultInfo, const struct FRVPDPPaintTaskResultInfo& PaintTaskResultInfo, const struct FRVPDPPaintColorSnippetSettings& PaintedColorSnippetSettings, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData);
	void PaintedOnActor_SetMeshComponentVertexColors(const struct FRVPDPTaskResults& TaskResultInfo, const struct FRVPDPPaintTaskResultInfo& PaintTaskResultInfo, const struct FRVPDPSetVertexColorsSettings& SetMeshComponentVertexColorSettings, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData);
	void PaintedOnActor_SetMeshComponentVertexColorsUsingSerializedString(const struct FRVPDPTaskResults& TaskResultInfo, const struct FRVPDPPaintTaskResultInfo& PaintTaskResultInfo, const struct FRVPDPSetVertexColorsUsingSerializedStringSettings& SetMeshComponentVertexColorUsingSerializedStringSettings, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData);
	void PaintedOnActor_WithinArea(const struct FRVPDPTaskResults& TaskResultInfo, const struct FRVPDPPaintTaskResultInfo& PaintTaskResultInfo, const struct FRVPDPPaintWithinAreaSettings& PaintedWithinAreaSettings, const struct FRVPDPWithinAreaResults& WithinAreaResults, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData);
	void PaintTaskFinishedOnRegisteredMeshComponent(const struct FRVPDPTaskResults& TaskResultInfo, const struct FRVPDPPaintTaskResultInfo& PaintTaskResultInfo, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintDetectionInterface">();
	}
	static class IVertexPaintDetectionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IVertexPaintDetectionInterface>();
	}
};
static_assert(alignof(IVertexPaintDetectionInterface) == 0x000008, "Wrong alignment on IVertexPaintDetectionInterface");
static_assert(sizeof(IVertexPaintDetectionInterface) == 0x000028, "Wrong size on IVertexPaintDetectionInterface");

// Class VertexPaintDetectionPlugin.VertexPaintDetectionSettings
// 0x0098 (0x00D0 - 0x0038)
class UVertexPaintDetectionSettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class UVertexPaintOptimizationDataAsset> OptimizationDataAssetToUse;                        // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UVertexPaintMaterialDataAsset> MaterialsDataAssetToUse;                           // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UVertexPaintColorSnippetRefs> ColorSnippetReferencesDataAssetToUse;              // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EditorWidgetNotificationEnabled;                   // 0x00B0(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EditorWidgetNotificationDuration;                  // 0x00B4(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDirectoryPath>                 EditorWidgetAdditionalPathsToLookUpAssets;         // 0x00B8(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         MaxAmountOfAllowedTasksPerMesh;                    // 0x00C8(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETVertexPaintThreadPriority                   MultithreadPriority;                               // 0x00CC(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseMaximumAmountOfCoresForMultithreading;          // 0x00CD(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CE[0x2];                                       // 0x00CE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintDetectionSettings">();
	}
	static class UVertexPaintDetectionSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexPaintDetectionSettings>();
	}
};
static_assert(alignof(UVertexPaintDetectionSettings) == 0x000008, "Wrong alignment on UVertexPaintDetectionSettings");
static_assert(sizeof(UVertexPaintDetectionSettings) == 0x0000D0, "Wrong size on UVertexPaintDetectionSettings");
static_assert(offsetof(UVertexPaintDetectionSettings, OptimizationDataAssetToUse) == 0x000038, "Member 'UVertexPaintDetectionSettings::OptimizationDataAssetToUse' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionSettings, MaterialsDataAssetToUse) == 0x000060, "Member 'UVertexPaintDetectionSettings::MaterialsDataAssetToUse' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionSettings, ColorSnippetReferencesDataAssetToUse) == 0x000088, "Member 'UVertexPaintDetectionSettings::ColorSnippetReferencesDataAssetToUse' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionSettings, EditorWidgetNotificationEnabled) == 0x0000B0, "Member 'UVertexPaintDetectionSettings::EditorWidgetNotificationEnabled' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionSettings, EditorWidgetNotificationDuration) == 0x0000B4, "Member 'UVertexPaintDetectionSettings::EditorWidgetNotificationDuration' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionSettings, EditorWidgetAdditionalPathsToLookUpAssets) == 0x0000B8, "Member 'UVertexPaintDetectionSettings::EditorWidgetAdditionalPathsToLookUpAssets' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionSettings, MaxAmountOfAllowedTasksPerMesh) == 0x0000C8, "Member 'UVertexPaintDetectionSettings::MaxAmountOfAllowedTasksPerMesh' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionSettings, MultithreadPriority) == 0x0000CC, "Member 'UVertexPaintDetectionSettings::MultithreadPriority' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionSettings, UseMaximumAmountOfCoresForMultithreading) == 0x0000CD, "Member 'UVertexPaintDetectionSettings::UseMaximumAmountOfCoresForMultithreading' has a wrong offset!");

// Class VertexPaintDetectionPlugin.VertexPaintDetectionTaskQueue
// 0x0198 (0x01C0 - 0x0028)
class UVertexPaintDetectionTaskQueue final : public UObject
{
public:
	uint8                                         Pad_28[0x40];                                      // 0x0028(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           TaskQueueThreadPoolResetTimer;                     // 0x0068(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FRVPDPCalculateColorsInfo> CalculateColorsPaintQueue;                         // 0x0078(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class UPrimitiveComponent*, struct FRVPDPTaskQueueIDInfo> ComponentPaintTaskIDs;                             // 0x00C8(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<int32, struct FRVPDPCalculateColorsInfo> CalculateColorsDetectionQueue;                     // 0x0118(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class UPrimitiveComponent*, struct FRVPDPTaskQueueIDInfo> ComponentDetectTaskIDs;                            // 0x0168(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B8[0x8];                                      // 0x01B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintDetectionTaskQueue">();
	}
	static class UVertexPaintDetectionTaskQueue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexPaintDetectionTaskQueue>();
	}
};
static_assert(alignof(UVertexPaintDetectionTaskQueue) == 0x000008, "Wrong alignment on UVertexPaintDetectionTaskQueue");
static_assert(sizeof(UVertexPaintDetectionTaskQueue) == 0x0001C0, "Wrong size on UVertexPaintDetectionTaskQueue");
static_assert(offsetof(UVertexPaintDetectionTaskQueue, TaskQueueThreadPoolResetTimer) == 0x000068, "Member 'UVertexPaintDetectionTaskQueue::TaskQueueThreadPoolResetTimer' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionTaskQueue, CalculateColorsPaintQueue) == 0x000078, "Member 'UVertexPaintDetectionTaskQueue::CalculateColorsPaintQueue' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionTaskQueue, ComponentPaintTaskIDs) == 0x0000C8, "Member 'UVertexPaintDetectionTaskQueue::ComponentPaintTaskIDs' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionTaskQueue, CalculateColorsDetectionQueue) == 0x000118, "Member 'UVertexPaintDetectionTaskQueue::CalculateColorsDetectionQueue' has a wrong offset!");
static_assert(offsetof(UVertexPaintDetectionTaskQueue, ComponentDetectTaskIDs) == 0x000168, "Member 'UVertexPaintDetectionTaskQueue::ComponentDetectTaskIDs' has a wrong offset!");

// Class VertexPaintDetectionPlugin.VertexPaintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UVertexPaintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AdjustBoxCollisionToFillAreaBetweenTwoLocations(class UBoxComponent* BoxCollision, const struct FVector& FromLocation, const struct FVector& ToLocation, float BoxThickness);
	static void AsyncLoadAssets(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const TArray<TSoftObjectPtr<class UObject>>& AssetsToLoad, bool PrintResultsToLog, TArray<class UObject*>* LoadedAssets, bool* Success, int32 AssetLoadPriority);
	static struct FBox CalcAABBWithoutUniformCheck(const class USkinnedMeshComponent* MeshComponent, const struct FTransform& LocalToWorld);
	static EObjectTypeQuery CollisionChannelToObjectType(ECollisionChannel CollisionChannel);
	static bool DoesPhysicsSurfaceBelongToPhysicsSurfaceFamily(const class UObject* WorldContextObject, EPhysicalSurface PhysicsSurface, EPhysicalSurface ParentOfPhysicsSurfaceFamily);
	static void DrawPrimitiveComponentBoundsBox(class UPrimitiveComponent* PrimitiveComponent, float Lifetime, float Thickness, const struct FLinearColor& ColorToDraw);
	static TArray<class FString> GetAllColorSnippetsUnderGroupSnippetAsString(const class UObject* WorldContextObject, const class FString& GroupSnippetID);
	static void GetAllMeshColorSnippetsAsString_Wrapper(class UPrimitiveComponent* MeshComponent, TMap<class FString, struct FRVPDPStoredColorSnippetInfo>* AvailableColorSnippetsAndDataAssets);
	static void GetAllMeshColorSnippetsAsTags_Wrapper(class UPrimitiveComponent* MeshComponent, TMap<struct FGameplayTag, TSoftObjectPtr<class UVertexPaintColorSnippetDataAsset>>* AvailableColorSnippetTagsAndDataAssets);
	static void GetAllMeshColorSnippetsTagsUnderTagCategory_Wrapper(class UPrimitiveComponent* MeshComponent, const struct FGameplayTag& TagCategory, TMap<struct FGameplayTag, TSoftObjectPtr<class UVertexPaintColorSnippetDataAsset>>* AvailableColorSnippetTagsAndDataAssetsUnderTagCategory);
	static TArray<EPhysicalSurface> GetAllPhysicsSurfaces();
	static TArray<struct FGameplayTag> GetAllTagsUnderTagCategory(const class UObject* WorldContextObject, const struct FGameplayTag& TagCategory);
	static TArray<ESurfaceAtChannel> GetAllVertexColorChannelsPhysicsSurfaceIsRegisteredTo_Wrapper(const class UObject* WorldContextObject, class UMaterialInterface* Material, EPhysicalSurface PhysicsSurface, bool* Successful);
	static int32 GetAmountOfColorSnippetChildsFromGroupSnippet(const class UObject* WorldContextObject, const struct FGameplayTag& GroupSnippet);
	static int32 GetAmountOfLODsToPaintOn(class UPrimitiveComponent* MeshComp, bool OverrideLODToPaintUpOn, int32 OverrideUpToLOD);
	static struct FRVPDPAmountOfColorsOfEachChannelResults GetAmountOfPaintedColorsForEachChannel(const TArray<struct FColor>& VertexColors, float MinColorAmountToBeConsidered);
	static void GetAmountOfPaintedColorsForEachChannelAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const TArray<struct FColor>& VertexColors, struct FRVPDPAmountOfColorsOfEachChannelResults* AmountOfColorsOfEachChannel, float MinColorAmountToBeConsidered);
	static TMap<class UPrimitiveComponent*, int32> GetCalculateColorsDetectionTasksAmount_Wrapper(const class UObject* WorldContextObject);
	static TMap<class UPrimitiveComponent*, int32> GetCalculateColorsPaintTasksAmount_Wrapper(const class UObject* WorldContextObject);
	static void GetChannelsPhysicsSurfaceIsRegisteredTo(const class UObject* WorldContextObject, class UMaterialInterface* MaterialToApplyColorsTo, const EPhysicalSurface& PhysicalSurface, bool* AtRedChannel, bool* AtGreenChannel, bool* AtBlueChannel, bool* AtAlphaChannel);
	static TArray<class UClothingAssetBase*> GetClothAssets(class USkeletalMesh* SkeletalMesh);
	static class UVertexPaintColorSnippetRefs* GetColorSnippetReferenceDataAsset(const class UObject* OptionalWorldContextObject);
	static void GetColorSnippetVertexColorsAsync(class UObject* WorldContextObject, const struct FGameplayTag& ColorSnippetTag, const struct FLatentActionInfo& LatentInfo, TSoftObjectPtr<class UObject>* ObjectSnippetIsAssociatedWith, TArray<struct FColor>* ColorSnippetVertexColors, bool* Success);
	static float GetComponentBoundsBottomWorldZ(class UPrimitiveComponent* Component);
	static float GetComponentBoundsTopWorldZ(class UPrimitiveComponent* Component);
	static struct FGameplayTag GetMeshColorSnippetChildFromGroupSnippet(class UPrimitiveComponent* MeshComponent, const struct FGameplayTag& GroupSnippet, const TArray<class UPrimitiveComponent*>& GroupSnippetMeshes, bool* Success);
	static void GetMeshColorSnippetsTagsInTagCategory_Wrapper(class UPrimitiveComponent* MeshComponent, const struct FGameplayTag& TagCategory, TMap<struct FGameplayTag, TSoftObjectPtr<class UVertexPaintColorSnippetDataAsset>>* AvailableColorSnippetTagsAndDataAssetsUnderTagCategory);
	static int32 GetMeshComponentAmountOfVerticesOnLOD(class UPrimitiveComponent* MeshComponent, int32 Lod);
	static const class UObject* GetMeshComponentSourceMesh(class UPrimitiveComponent* MeshComponent);
	static struct FRVPDPVertexDataInfo GetMeshComponentVertexColors_Wrapper(class UPrimitiveComponent* MeshComponent, bool* Success, bool GetColorsForAllLODs, int32 GetColorsUpToLOD);
	static TArray<struct FColor> GetMeshComponentVertexColorsAtLOD_Wrapper(class UPrimitiveComponent* MeshComponent, int32 Lod);
	static class UVertexPaintOptimizationDataAsset* GetOptimizationDataAsset(const class UObject* OptionalWorldContextObject);
	static TArray<EPhysicalSurface> GetParentsOfPhysicsSurface_Wrapper(const class UObject* WorldContextObject, EPhysicalSurface PhysicalSurface);
	static class UPhysicalMaterial* GetPhysicalMaterialUsingPhysicsSurface_Wrapper(const class UObject* WorldContextObject, TSubclassOf<class UPhysicalMaterial> PhysicalMaterialClass, EPhysicalSurface PhysicsSurface);
	static TMap<EPhysicalSurface, struct FRVPDPRegisteredPhysicsSurfacesSettings> GetPhysicsSurfaceFamilies_Wrapper(const class UObject* WorldContextObject);
	static TArray<EPhysicalSurface> GetPhysicsSurfacesRegisteredToMaterial(const class UObject* WorldContextObject, class UMaterialInterface* Material);
	static class FString GetSubstringAfterLastCharacter(const class FString& String, const class FString& Character);
	static bool GetTheGroupSnippetAChildSnippetBelongsTo(const class UObject* WorldContextObject, const struct FGameplayTag& childSnippet, struct FGameplayTag* groupSnippetChildBelongsTo);
	static bool GetTheMostDominantPhysicsSurface_Wrapper(const class UObject* WorldContextObject, class UMaterialInterface* OptionalMaterialPhysicsSurfaceWasDetectedOn, const TArray<EPhysicalSurface>& PhysicsSurfaces, const TArray<float>& PhysicsSurfaceValues, EPhysicalSurface* MostDominantPhysicsSurfaceFromArray, float* MostDominantPhysicsSurfaceColorValue);
	static class UVertexPaintMaterialDataAsset* GetVertexPaintMaterialDataAsset(const class UObject* OptionalWorldContextObject);
	static TMap<TSoftObjectPtr<class UMaterialInterface>, struct FRVPDPRegisteredMaterialSetting> GetVertexPaintMaterialInterface_Wrapper(const class UObject* WorldContextObject);
	static bool IsAssetsLoaded(class UObject* WorldContextObject, const TArray<TSoftObjectPtr<class UObject>>& AssetsToCheck);
	static bool IsMaterialAddedToPaintOnMaterialDataAsset_Wrapper(const class UObject* WorldContextObject, TSoftObjectPtr<class UMaterialInterface> Material);
	static bool IsPlayInEditor(const class UObject* WorldContextObject);
	static bool IsWorldValid(const class UWorld* World);
	static bool MultiSphereTraceForClosestUniqueMeshesAndBones_Wrapper(const class UObject* WorldContextObject, const struct FVector& Location, float Radius, ETraceTypeQuery TraceChannel, const TArray<EObjectTypeQuery>& ObjectTypesToTraceFor, const TArray<class AActor*>& ActorsToIgnore, bool TraceComplex, bool IgnoreSelf, EDrawDebugTrace DrawDebugType, TArray<struct FRVPDPTraceForClosestUniqueMeshesAndBonesPrerequisite>* ClosestUniqueMeshesWithBones, float DebugDrawTime);
	static ECollisionChannel ObjectTypeToCollisionChannel(EObjectTypeQuery ObjectType);
	static void RegisterDetectTaskCallbacksToObjectFromSpecifiedMeshComponent_Wrapper(class UPrimitiveComponent* MeshComponent, class UObject* ObjectToRegisterForCallbacks);
	static void RegisterPaintTaskCallbacksToObjectFromSpecifiedMeshComponent_Wrapper(class UPrimitiveComponent* MeshComponent, class UObject* ObjectToRegisterForCallbacks);
	static struct FLinearColor ReliableFColorToFLinearColor(const struct FColor& Color);
	static struct FColor ReliableFLinearToFColor(const struct FLinearColor& LinearColor);
	static void RemoveComponentFromDetectTaskQueue(class UPrimitiveComponent* Component);
	static void RemoveComponentFromPaintTaskQueue(class UPrimitiveComponent* Component);
	static void SetChaosClothPhysics(class USkeletalMeshComponent* SkeletalMeshComponent, class UClothingAssetBase* ClothingAsset, const struct FRVPDPChaosClothPhysicsSettings& ClothPhysicsSettings);
	static void SetChaosWheeledVehicleFrictionMultiplier_Wrapper(class UChaosWheeledVehicleMovementComponent* ChaosWheeledVehicleMovementComponent, int32 WheelIndex, float Friction);
	static class UDynamicMesh* SetMeshConstantVertexColorsAndEnablesThem(class UDynamicMesh* TargetMesh, const struct FLinearColor& Color, const struct FGeometryScriptColorFlags& Flags_0, bool bClearExisting, class UGeometryScriptDebug* Debug);
	static void SetSkeletalMeshAndReleaseResources(class USkeletalMeshComponent* SkeletalMeshComponent, class USkeletalMesh* NewMesh, bool ClearVertexColorsOfChangedMesh);
	static void SetStaticMeshAndReleaseResources(class UStaticMeshComponent* StaticMeshComponent, class UStaticMesh* NewMesh, bool ClearVertexColorsOfChangedMesh);
	static void UnRegisterDetectTaskCallbacksToObjectFromSpecifiedMeshComponent_Wrapper(class UPrimitiveComponent* MeshComponent, class UObject* ObjectToUnregisterForCallbacks);
	static void UnRegisterPaintTaskCallbacksToObjectFromSpecifiedMeshComponent_Wrapper(class UPrimitiveComponent* MeshComponent, class UObject* ObjectToUnregisterForCallbacks);
	static void UpdateChaosClothPhysicsWithExistingColors(class USkeletalMeshComponent* SkeletalMeshComponent);
	static void UpdateChaosClothPhysicsWithExistingColorsAsync(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class USkeletalMeshComponent* SkeletalMesh);
	static class USkeletalMesh* VertexPaintDetectionPlugin_GetSkeletalMesh(class USkeletalMeshComponent* SkeletalMeshComp);
	static TMap<int32, class FString> VertexPaintDetectionPlugin_SortAssetsNamesAlphabetically(const TMap<int32, class FString>& AssetIndexAndName);
	static TArray<class FString> VertexPaintDetectionPlugin_SortStringArrayAlphabetically(const TArray<class FString>& Strings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintFunctionLibrary">();
	}
	static class UVertexPaintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexPaintFunctionLibrary>();
	}
};
static_assert(alignof(UVertexPaintFunctionLibrary) == 0x000008, "Wrong alignment on UVertexPaintFunctionLibrary");
static_assert(sizeof(UVertexPaintFunctionLibrary) == 0x000028, "Wrong size on UVertexPaintFunctionLibrary");

// Class VertexPaintDetectionPlugin.VertexPaintMaterialDataAsset
// 0x00A0 (0x00D0 - 0x0030)
class UVertexPaintMaterialDataAsset final : public UDataAsset
{
public:
	TMap<TSoftObjectPtr<class UMaterialInterface>, struct FRVPDPRegisteredMaterialSetting> VertexPaintMaterialInterfaces;                     // 0x0030(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<EPhysicalSurface, struct FRVPDPRegisteredPhysicsSurfacesSettings> PhysicsSurfaceFamilies;                            // 0x0080(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintMaterialDataAsset">();
	}
	static class UVertexPaintMaterialDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexPaintMaterialDataAsset>();
	}
};
static_assert(alignof(UVertexPaintMaterialDataAsset) == 0x000008, "Wrong alignment on UVertexPaintMaterialDataAsset");
static_assert(sizeof(UVertexPaintMaterialDataAsset) == 0x0000D0, "Wrong size on UVertexPaintMaterialDataAsset");
static_assert(offsetof(UVertexPaintMaterialDataAsset, VertexPaintMaterialInterfaces) == 0x000030, "Member 'UVertexPaintMaterialDataAsset::VertexPaintMaterialInterfaces' has a wrong offset!");
static_assert(offsetof(UVertexPaintMaterialDataAsset, PhysicsSurfaceFamilies) == 0x000080, "Member 'UVertexPaintMaterialDataAsset::PhysicsSurfaceFamilies' has a wrong offset!");

// Class VertexPaintDetectionPlugin.VertexPaintOptimizationDataAsset
// 0x00F0 (0x0120 - 0x0030)
class UVertexPaintOptimizationDataAsset final : public UDataAsset
{
public:
	TMap<class UStaticMesh*, struct FRVPDPPaintOnLODSettings> StaticMeshNumOfLODsToPaint;                        // 0x0030(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<class USkeletalMesh*, struct FRVPDPPaintOnLODSettings> SkeletalMeshNumOfLODsToPaint;                      // 0x0080(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)
	TMap<class USkeletalMesh*, struct FRVPDPRegisteredSkeletalMeshInfo> RegisteredSkeletalMeshInfo;                        // 0x00D0(0x0050)(Edit, EditConst, NativeAccessSpecifierPrivate)

public:
	TMap<class USkeletalMesh*, struct FRVPDPRegisteredSkeletalMeshInfo> GetRegisteredSkeletalMeshInfo() const;
	TMap<class USkeletalMesh*, struct FRVPDPPaintOnLODSettings> GetSkeletalMeshNumOfLODsToPaint() const;
	TMap<class UStaticMesh*, struct FRVPDPPaintOnLODSettings> GetStaticMeshNumOfLODsToPaint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintOptimizationDataAsset">();
	}
	static class UVertexPaintOptimizationDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexPaintOptimizationDataAsset>();
	}
};
static_assert(alignof(UVertexPaintOptimizationDataAsset) == 0x000008, "Wrong alignment on UVertexPaintOptimizationDataAsset");
static_assert(sizeof(UVertexPaintOptimizationDataAsset) == 0x000120, "Wrong size on UVertexPaintOptimizationDataAsset");
static_assert(offsetof(UVertexPaintOptimizationDataAsset, StaticMeshNumOfLODsToPaint) == 0x000030, "Member 'UVertexPaintOptimizationDataAsset::StaticMeshNumOfLODsToPaint' has a wrong offset!");
static_assert(offsetof(UVertexPaintOptimizationDataAsset, SkeletalMeshNumOfLODsToPaint) == 0x000080, "Member 'UVertexPaintOptimizationDataAsset::SkeletalMeshNumOfLODsToPaint' has a wrong offset!");
static_assert(offsetof(UVertexPaintOptimizationDataAsset, RegisteredSkeletalMeshInfo) == 0x0000D0, "Member 'UVertexPaintOptimizationDataAsset::RegisteredSkeletalMeshInfo' has a wrong offset!");

// Class VertexPaintDetectionPlugin.VertexPaintTasksFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UVertexPaintTasksFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void GetAllVertexColorsOnly_Wrapper(class UVertexPaintDetectionComponent* RuntimeVertexPaintAndDetectionComponent, class UPrimitiveComponent* MeshComponent, const struct FRVPDPGetColorsOnlySettings& GetAllVertexColorsStruct, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalDataToPassThrough);
	static void GetClosestVertexDataOnMesh_Wrapper(class UVertexPaintDetectionComponent* RuntimeVertexPaintAndDetectionComponent, class UPrimitiveComponent* MeshComponent, const struct FRVPDPGetClosestVertexDataSettings& GetClosestVertexDataStruct, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalDataToPassThrough);
	static void GetColorsWithinArea_Wrapper(class UVertexPaintDetectionComponent* RuntimeVertexPaintAndDetectionComponent, class UPrimitiveComponent* MeshComponent, const struct FRVPDPGetColorsWithinAreaSettings& GetColorsWithinAreaStruct, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalDataToPassThrough);
	static void PaintColorSnippetOnMesh_Wrappers(class UVertexPaintDetectionComponent* RuntimeVertexPaintAndDetectionComponent, class UPrimitiveComponent* MeshComponent, const struct FRVPDPPaintColorSnippetSettings& PaintColorSnippetStruct, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalDataToPassThrough);
	static void PaintGroupSnippetOnMesh_Wrapper(class UVertexPaintDetectionComponent* RuntimeVertexPaintAndDetectionComponent, const TArray<class UPrimitiveComponent*>& GroupSnippetMeshes, const struct FRVPDPPaintGroupSnippetSettings& PaintGroupSnippetStruct, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalDataToPassThrough);
	static void PaintOnEntireMesh_Wrapper(class UVertexPaintDetectionComponent* RuntimeVertexPaintAndDetectionComponent, class UPrimitiveComponent* MeshComponent, const struct FRVPDPPaintOnEntireMeshSettings& PaintOnEntireMeshStruct, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalDataToPassThrough);
	static void PaintOnMeshAtLocation_Wrapper(class UVertexPaintDetectionComponent* RuntimeVertexPaintAndDetectionComponent, class UPrimitiveComponent* MeshComponent, const struct FRVPDPPaintAtLocationSettings& PaintAtLocationStruct, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalDataToPassThrough);
	static void PaintOnMeshWithinArea_Wrapper(class UVertexPaintDetectionComponent* RuntimeVertexPaintAndDetectionComponent, class UPrimitiveComponent* MeshComponent, const struct FRVPDPPaintWithinAreaSettings& PaintWithinAreaStruct, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalDataToPassThrough);
	static void SetMeshComponentVertexColors_Wrapper(class UVertexPaintDetectionComponent* RuntimeVertexPaintAndDetectionComponent, class UPrimitiveComponent* MeshComponent, const struct FRVPDPSetVertexColorsSettings& SetMeshComponentVertexColorsSettings, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalDataToPassThrough);
	static void SetMeshComponentVertexColorsUsingSerializedString_Wrapper(class UVertexPaintDetectionComponent* RuntimeVertexPaintAndDetectionComponent, class UPrimitiveComponent* MeshComponent, const struct FRVPDPSetVertexColorsUsingSerializedStringSettings& SetMeshComponentVertexColorsUsingSerializedStringSettings, const struct FRVPDPAdditionalDataToPassThroughInfo& AdditionalDataToPassThrough);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexPaintTasksFunctionLibrary">();
	}
	static class UVertexPaintTasksFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexPaintTasksFunctionLibrary>();
	}
};
static_assert(alignof(UVertexPaintTasksFunctionLibrary) == 0x000008, "Wrong alignment on UVertexPaintTasksFunctionLibrary");
static_assert(sizeof(UVertexPaintTasksFunctionLibrary) == 0x000028, "Wrong size on UVertexPaintTasksFunctionLibrary");

}

